# 第八章--排序

## 8.1 插入类排序

### 8.1.1 直接插入排序

> 在从后向前的比较过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入位置
>
> 元素越**有序**，直接插入排序的速度越**快**

### 8.1.2 折半插入排序

> 从时间上比较，折半插入排序**仅仅减少**了关键字的**比较次数**，却没有减少记录的移动次数
>
> **比较次数** 取决于表中**元素个数**，与排序表的**初始状态** **无关**
>
> **移动次数** 取决于 **排序表的初始状态**

### 8.1.3 希尔排序

> 希尔排序（缩小增量排序）：先取一个小于 n 的**步长 d1**，所有距离为 d1 的倍数的记录放在同一组，组内部采用**直接插入排序**

> 

### 插入类排序算法比较

| *插入排序* | 直接插入排序                                               | 折半插入排序 | 希尔排序                               |
| ---------- | ---------------------------------------------------------- | ------------ | -------------------------------------- |
| 时间复杂度 | 最好情况：O(n)<br />最坏情况：O(n^2)<br />平均情况：O(n^2) | O(n^2)       | 优于直接插入排序<br />最坏情况：O(n^2) |
| 空间复杂度 | O(1)                                                       | O(1)         | O(1)                                   |
| 稳定性     | 稳定                                                       | 稳定         | ==不稳定==                             |
| 适用性     | 顺序表、链表                                               | 顺序表、链表 | 顺序表、链表                           |



## 8.2 交换类排序

### 8.2.1 冒泡排序

> n 个元素，最多需要 n-1 趟排序，且**每一趟排序**都可以使**一个元素**移动到**最终位置**

> - 比较次数 = **n(n-1)/2**
> - 移动次数 = **3n(n-1)/2**

### 8.2.2 快速排序

> 快速排序是**递归**的，需要借助**系统栈**，且**递归次数**与**处理顺序无关**，只与 **各元素的初始状态** ==有关==
>
> 元素越**无序**，快排的**性能越好**；元素越有序，快排的性能越差
>
> **快速排序**是所有**内部排序算法**中平均性能==最优==的排序算法

> 排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一"趟" ，每趟只能确定枢轴元素的最终位置
>
> 快排的阶段性排序结果的特点：在**第 i 趟**完成时，会有 **i 个以上的数（i 为枢轴元素个数）**出现在它最终将出现的位置

> 基本思想：
>
> 1. 选定 Pivot 中心轴
> 2. 将 **大于** Pivot 的数字放在 Pivot 的 **右边 R**
> 3. 将 **小于** Pivot 的数字放在 Pivot 的 **左边 L**
> 4. 分别对左右子树序列重复前三步操作
>
> 当每次的枢轴都把表等分为**长度相近**的两个子表时，**速度最快**
>
> 当表本身已经有序或逆序时，速度最慢

### 交换类排序算法比较

| *交换排序* | 冒泡排序                                                     | 快速排序                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 时间复杂度 | 最好情况（有序）：O(n)<br />最坏情况（逆序）：O(n^2)<br />平均情况：O(n^2) | 最好情况（无序）：==O(n log2 n)==<br />最坏情况（有序）：O(n^2)<br />平均情况：O(n^2) |
| 空间复杂度 | O(1)                                                         | 最好情况（栈的**最小**递归深度）：==O(log2 n)==<br />最坏情况（栈的**最大**递归深度）：==O(n)==<br />平均情况：==O(log2 n)== |
| 稳定性     | 稳定                                                         | ==不稳定==                                                   |
| 适用性     | 顺序表、链表                                                 | 顺序表                                                       |



## 8.3 选择类排序

### 8.3.1 简单选择排序

> 每趟都是从无序序列中一个个比较找到**关键字最小**元素，将其和无序序列的首元素交换
>
> 每趟可以确定一个元素的最终位置

> - 元素间的**比较次数**与**序列的初始状态**  ==无关==，始终是 **n(n-1)/2** ，即 **O(n^2) 次**
> - 元素间的**移动次数**小于 n - 1，即 **O(n) 次**

### 8.3.2 堆排序

<strong style="color:#DD5145">一般用堆来实现具有优先级的队列</strong>。

> 采用**完全二叉树**结构进行排序的方法
>
> 堆（Heap）的结构正好与该序列结构完全一致，即**堆的序列就是完全二叉树的层次遍历**
>
> 二叉排序树会得到一个有序的序列，而堆则不一定能得到一个有序的序列

> - **大根堆：** 最大元素存放在根结点
> - **小根堆：** 最小元素存放在根结点
> - 左、右子树大小没有规定

> - 初始堆调整：自下而上，从右到左；先兄弟，后父子
> - 输出堆顶元素，将堆的最后一个元素与堆顶元素交换，然后从上往下调整
> - 插入元素，将新结点放在堆的末端，然后从下往上调整

> 在**建立**含 n 个元素的堆时，关键字的**比较次数** <= **4n**
>
> 每次**调整**的时间复杂度为 O(h)，h 为完全二叉树的树高**【log2 n】+ 1**（向下取整）

> 适用于**从 n 个元素中获取前 k 个元素**，复杂度比较低

### 选择类排序算法比较

| *选择排序* | 简单选择排序 | 堆排序                                    |
| ---------- | ------------ | ----------------------------------------- |
| 时间复杂度 | O(n^2)       | 建立堆：O(n)<br />调整堆：==O(n log2 n)== |
| 空间复杂度 | O(1)         | O(1)                                      |
| 稳定性     | ==不稳定==   | ==不稳定==                                |
| 适用性     | 顺序表、链表 | 顺序表                                    |



## 8.4 归并排序和基数排序

### 8.4.1 二路归并排序

> - **归并** 是指将两个或两个以上的有序表组合成一个新的有序表
> - **二路归并** 是指将每个子表长度为 1 的**两两归并**，然后循环往复
> - 一趟归并：双指针，不回溯
>
> **归并排序 **是本章所有的算法中 **占用空间最多** 的排序算法

> n 个元素进行 **k 路归并排序**时，排序趟数 **m = 【logk n】**（向上取整）

### 8.4.2 基数排序

> 基数排序（桶排序或数字排序）：<strong style="color:#DD5145">不需要进行关键字的比较和元素的移动</strong>。
>
> - 将整个关键字拆分为 d 位（或 "组"），做 d 趟 "**分配**" 和 "**收集**"
> - 若关键字由 r 位子关键字构成，则需要建立 **r 个队列**

> - 最高位优先（MSD）法
> - 最低位优先（LSD）法
>
> 适用于：1.数据元素的关键字可以方便拆分为 d 组，且 d 较小
>                2.每组关键字的取值范围不大，即 r 较小
>                3.数据元素个数 n 较大

### 归并与基数排序比较

|            | 归并排序        | 基数排序        |
| ---------- | --------------- | --------------- |
| 时间复杂度 | ==O(n log2 n)== | **O( d(n+r) )** |
| 空间复杂度 | ==O(n)==        | ==O(r)==        |
| 稳定性     | 稳定            | 稳定            |
| 适用性     | 顺序表          | 顺序表、链表    |



## 8.5 内部排序算法总结

> - 每趟排序 **无法确定** 元素最终位置的是 **插入类排序**（插入排序、希尔排序）、**归并排序**、**基数排序**
> - 每趟排序均 **可确定** 一个元素最终位置的是 **交换类排序**（冒泡、快速排序）、**选择类排序**（简单选择、堆排序）

> - **排序趟数** 与 元素的 **初始状态** ==有关== 的是 **快速排序**
> - 与 **初始状态** ==无关== 的是 **插入类排序** （插入排序、希尔排序）、**冒泡排序**、**选择类排序**（简单选择、堆排序）、**归并排序**

> - 若 n 比较 **小** 时，可采用 直接插入排序、简单选择排序
> - 若 n 比较 **大** 时，可采用 时间复杂度为 **O(n log2 n)** 的 **快速排序**、**堆排序**、**归并排序**
> - 若文件的 **初始状态** 已按关键字基本 **有序**，可采用 **直接插入排序**、**冒泡排序**

> - 一般需要采用 ==顺序结构== 存储的排序算法是 **快速排序**、**堆排序**、**归并排序**
> - 其他算法可以采用顺序结构和链式结构

> - 平均 **时间复杂度** 为 **O(n log2 n)** 的 **稳定** 排序算法只有 **归并排序**
>
> - ==不稳定== 的排序算法：**希尔排序**、**快速排序**、**选择类排序**（简单选择排序、堆排序）

> - 算法的 **时间复杂度** 和 **比较次数** 与 元素的初始状态 ==无关== 的是 **简单选择排序**、**归并排序**、**基数排序**
>- 对于任意 n 个关键字排序的 **比较次数** **至少** 为**【log2 (n!)】**次（向上取整）

| 排序算法     | 稳定性     | 时间复杂度                                                   | 空间复杂度                                                   | 排序趟数             | 与元素的初始状态 |
| ------------ | ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------- | ---------------- |
| 直接插入排序 | 稳定       | 最好情况：O(n)<br />最坏情况：O(n^2)<br />平均情况：O(n^2)   | O(1)                                                         | n-1                  | \                |
| 折半插入排序 | 稳定       | O(n^2)                                                       | O(1)                                                         | n-1                  | \                |
| 希尔排序     | ==不稳定== | 优于直接插入排序<br />最坏情况：O(n^2)                       | O(1)                                                         | 无法定量分析         | \                |
| 冒泡排序     | 稳定       | 最好情况（有序）：O(n)<br />最坏情况（逆序）：O(n^2)<br />平均情况：O(n^2) | O(1)                                                         | n-1                  | \                |
| **快速排序** | ==不稳定== | 最好情况（无序）：==O(n log2 n)==<br />最坏情况（有序）：O(n^2)<br />平均情况：==O(n log2 n)== | 最好情况：O(log2 n)<br />最坏情况：O(n)<br />平均情况：O(log2 n) |                      | ==有关==         |
| 简单选择排序 | ==不稳定== | 三者都是：O(n^2)                                             | O(1)                                                         | n-1                  | \                |
| 堆排序       | ==不稳定== | 建立堆：O(n)<br />调整堆：==O(n log2 n)==                    | O(1)                                                         | n-1                  | \                |
| 2路归并排序  | **稳定**   | 三者都是：==O(n log2 n)==                                    | ==O(n)==                                                     | log2 n               | \                |
| 基数排序     | 稳定       | 三者都是：O( d(n+r) )                                        | **O(r)**                                                     | 不需要进行比较和移动 |                  |

## 8.6 外部排序

### 8.6.1 外部排序的方法

外部排序：数据元素太多，无法一次全部读入内存进行排序，在排序过程中需要多次进行内存和外存的交换

外部排序通常采用 **归并排序法**

最少只需要在内存中分配 3 快大小的缓冲区即可对任意一个大文件进行排序

> **外部排序的总时间 = 内部排序所需时间 + 外存信息读写时间 + 内部归并所需时间**
>
> 外存信息读写时间（以磁盘块为单位）远大于内部排序时间和内部归并时间，应该着力减少 I/O 次数

> 一般对 r 个初始归并段，做 k 路平衡归并，归并树可用**严格 k 叉树**（只有度为 0 和 k 的结点的 k 叉树）来表示
>
> **树高 - 1 = 【logk r】（向上取整）= 归并趟数S**
>
> 只要增大归并路数 k ，或减少初始归并段个数 r ，即可减少归并趟数S，进而减少磁盘 I/O 次数

### 8.6.2 败者树

引入 "败者树" 减少关键字对比次数

> 对于 k 路归并，第一次构造败者树需要对比关键字 k-1 次
>
> 使用败者树后，**选出最小元素**，只需要对比关键字 【log2 k】次（向上取整）
>
> 使用败者树后，内部归并的比较次数与 k 无关了

只要空间允许，适当地增大归并路数 k 将有效减少归并树的高度，从而减少 I/O 次数，提高外部排序的速度

### 8.6.3 置换-选择排序

利用置换-选择排序（生成初始归并段）增大归并段长度，从而减少初始归并段的个数

> 初始待排序文件为 FI，初始归并段输出文件为 FO，内存工作区为 WA，且 FO 和 WA 的初始态为空
>
> 每个初始归并段的长度可以超过内存工作区 WA 的大小限制

### 8.6.4 最佳归并树

归并树可以采用**哈夫曼树**的思想，总的 I/O 次数最少的为最佳归并树

最佳归并树的作用：设计 m 路归并排序的优化方案

归并过程中的 **磁盘 I/O 次数 = 归并树的 WPL * 2**

若初始归并段不足以构成一颗严格的 k 叉归并树时，需要添加长度为 0 的 **"虚段"**，再进行 k 叉哈夫曼树的构造

> - 若**（初始归并段数量 - 1）%（k - 1）** = 0 时，则不需要添加 "虚段"
> - 若（初始归并段数量 - 1）%（k - 1） = u（u不等于 0）时，则需要补充**（k-1）- u** 个 "虚段"