# 第三章--栈、队列和数组

## 3.1 栈

> 1. **什么时候栈空？**
>
>    S.top == S.bottom == ==-1==，出栈之前要先判断栈是否为空
>
> 2. **如何进栈？**
>
>    进栈先判断栈是否为满栈，==然后 S.top ++，最后 push 元素==，否则产生上溢
>
>    因为初始化时 S.top == -1，是不合法的范围，所以要 S.top ++
>
> 3. **栈顶指针指向哪里？**
>
>    栈顶指针 top 指向栈顶元素
>
> 4. **如何出栈？**
>
>    出栈先判断栈是否为空栈，==然后 pop 元素，最后 S.top --==，否则产生下溢
>
> 5. **栈底指针指向哪里？**
>
>    栈底指针固定不变，指向初始的位置
>
> 6. **什么时候满栈？**
>
>    静态顺序栈：当 S.top == n-1 时，栈满
>
>    动态顺序栈：当 |S.top - S.bottom| >= n 时，栈满
>
> 7. **栈中元素有几个？**
>
>    有 |S.top - S.bottom| 个元素
>
> 以上问题与栈的初始化有关
>
> 默认情况是 S.top == S.bottom == ==0==，即 ==进栈时，先 push，后 top ++==；==出栈时，先 top --，后 pop==
>
> 还有另外两种情况 top == bottom == n（或 n+1），即以高端地址作为栈底

> - 上溢（overflow）：栈已经满了，还要 push 元素（一种错误）
> - 下溢（underflow）：栈已经空了，还要 pop 元素（结束条件）

### 3.1.1 顺序栈

### 3.1.2 链栈

###  3.1.3 栈的基本操作

1. **进栈**，栈顶指针为top，插入一个x结点

   **不带头结点**

   ```
   x->next=top; top=x;
   ```

   **带头结点**

   ```
   x->next=top->next; top->next=x;
   ```

2. **出栈**，栈顶指针为top，并将出栈元素存在x中

   **不带头结点**

   ```
   x=top->data; top=top->next;
   ```

   **带头结点**

   ```
   x=top->next->data; top->next=top->next->next;
   ```

## 3.2 队列

### 3.2.1 顺序队列

### 3.2.2 循环队列

### 3.2.3 链队列

1. 入队操作

   ```
   s->data=x; s->next=NULL;	//创建新节点s，数据域为x，插入到链尾，故s->next必须置为空
   Q.rear->next=s;
   Q.rear=s;
   ```

2. 出队操作

### 3.2.4 双端队列

## 3.3 栈的应用

### 括号匹配

### 进制转换

### 函数递归调用

### 表达式求值

> 1. 转换前先建立两个栈，命名为 s1 和 s2。用栈 s1 存储表达式的操作数，栈 s2 存储运算符
>
> 2. 在转换的过程中，需要从左到右扫描中缀表达式的每一个操作数和运算符，若为操作数则压入栈 s1
>
> 3. 若扫描到的是运算符，设符号为 C，则可能出现以下情况：
>
>    a.若 s2 为 ==空==，则将 C 压入到栈 s2 中
>
>    b.若 s2 的 ==栈顶符号为左括号==，则将 C 压入到栈 s2 中
>
>    c.若 C 为 ==左括号==，则将 C 压入到栈 s2 中
>
>    d.若 C 的优先级 ==大于== s2 的栈顶符号的优先级，则将 C 压入到栈 s2 中（==右括号== 的优先级 ==最低==）
>
>    e.否则，就将 s2 栈顶的运算符弹出，从 s1 中弹出两个（也可能是一个）操作数，进行运算，并把运算的结果压回 栈 s1
>
> 4. 扫描到表达式结束，若最后栈 s2 中还有运算符，则依次弹出栈，并从 s1 中弹出两个（也可能是一个）操作数，进行运算，最后把运算结果压回栈 s1

运算数的顺序不变

1. **后缀表达式求值的步骤：**左操作数+右操作数+运算符

> 1. 从左往右扫描下一个元素，直到，处理完所有元素
> 2. 若扫描到操作数则压入栈中，并回到步骤1，否则执行步骤3
> 3. 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到步骤1

2. **中缀表达式转后缀表达式步骤：**

> 初始化一个栈，用于保存暂时还不能确定运算顺序的运算符，从左到右扫描各个元素，直到末尾
>
> 1. 若扫描到 ==操作数==，则直接加入到后缀表达式
>
> 2. 若扫描到 ==界限符==，则可能出现以下情况：
>
>    a.遇到 " ( " 则直接压入栈中，注意： " ( " 不加入后缀表达式
>
>    b.遇到 " ) " 则依次弹出栈内运算符，并加入后缀表达式，直到弹出 " ( " 为止
>
> 3. 若扫描到 ==运算符==，依次弹出栈中 ==优先级高于或等于== 当前运算符的所有运算符，并加入后缀表达式，若遇到栈顶元素为 " ( " 或 栈空 则停止，然后把当前运算符压入栈中

## 3.4 队列的应用

## 3.5 数组和特殊矩阵

### 3.5.1 对称矩阵

> 对于n阶对称矩阵，只存放下三角部分（含主对角）的元素，压缩存储在表长为 n(n+1)/2 的顺序表中（数组下标从1开始）
>
>  若数组下标从0开始，则是 n(n+1)/2 - 1
>
> ==要注意数组下标是从0开始还是从1开始==
>
> ==C语言中数组下标是从 0 开始==

### 3.5.2 三角矩阵

> 上三角区域的所有元素均为同一常量
>
> 下三角矩阵 A[1...n] [1...n] 压缩存储在数组 B[n(n+1)/2 + 1] （**加 1 是多存储了一个常量**）中（数组下标从1开始）
>
> 若数组下标从0开始，则是 n(n+1)/2 

### 3.5.3 三对角矩阵（带状矩阵）

> 所有非零元素都集中在以主对角线为中心的 **3 条对角线** 的区域，其他区域的元素全为零

### 3.5.4 稀疏矩阵

> 采用 **三元组顺序表**、**十字链表** 存储非零元素
>
> 稀疏矩阵压缩存储之后，会失去随机存取的特性12