# 第七章--查找

**静态**查找表的查找方法：顺序查找、折半查找、散列查找

**动态**查找表的查找方法：二叉排序树的查找、散列查找

关键字：数据元素中唯一标识该元素的某个数据项的值

平均查找长度ASL

## 7.1 顺序查找

顺序查找（线性查找），对于**顺序表**和**链表**都适用，时间复杂度为 O(n)

- ASL成功 = (n+1) / 2
- ASL不成功 = n+1 ，不成功是位置是1个（哨兵只有1个）

对线性的链表只能进行顺序查找

## 7.2 折半查找

折半查找（二分查找），仅适用于<strong style="color:#DD5145">有序的顺序表（可随机存取）</strong>，不适用于链表，时间复杂度为 O(log2 n)

折半查找的过程可用一个二叉树来描述，称为**判定树**（折半树或二叉搜索树），判定树是一颗**平衡二叉树**

> - 判定树的次数只和元素的个数有关，而与元素具体什么内容无关
> - 每个结点值均大于其左子结点值，且均小于其右子结点值
> - 比较**次数**最多不会超过树的高度 h =【log2 (n+1)】(向上取整)

## 7.3 分块查找

分块查找（索引顺序查找），块内无序（顺序查找），块间有序（可顺序、折半）

> 长度为 n 的查找表均匀地分为 b 块，每块有 s 个记录，Li为索引查找的ASL，Ls为块内查找的ASL
>
> 1. 块内和索引表都采用顺序查找
>
>    ASL = Li + Ls = (b+1)/2 + (s+1)/2 = （s^2 + 2s + n）/ 2s
>
>    若s = 根号n时，ASL取的最小值 根号n +1
>
> 2. 索引表采用折半查找
>
>    ASL =【log2 (b+1)】+（s+1）/ 2，（向上取整）
>
> 3. 若s = 根号n时，ASL取的最小值 根号n +1

**线性结构**

|            | 顺序查找  | 折半查找(二分查找) | 分块查找 |
| ---------- | --------- | ------------------ | -------- |
| 时间复杂度 | O(n)      | O(log2 n)          |          |
| 空间复杂度 |           |                    |          |
| ASL成功    | (n+1) / 2 |                    |          |
| ASL失败    | n+1       |                    |          |



## 7.4 树型查找

### 7.4.1 二叉排序树（BST）

一颗二叉排序树（二叉查找树）或是一颗空树：

> - 若左子树为空，则左子树上所有结点的值均小于根结点的值
> - 若右子树为空，则右子树上所有结点的值均大于根结点的值
> - 左、右子树也分别是一颗二叉排序树
>
> <strong style="color:#DD5145">左子树结点值 < 根结点 < 右子树结点值</strong>
>
> 所以，对二叉树进行<strong style="color:#DD5145">中序遍历</strong>，可以得到一个<strong style="color:#DD5145">递增</strong>的有序序列

1. **BST 的查找**

   ASL与树的深度是等数量级

2. **BST 的插入**

   插入的结点一定是一个新添加的**叶子结点**

3. **BST 的构造**

   关键字的输入顺序不同，建立的二叉排序树不同

4. **BST 的删除**

> 1. 若被删除结点 z 是叶结点，则直接删除
> 2. 若结点 z 只有一颗左子树或右子树，则让 z 的子树成为父结点的子树，代替 z 的位置
> 3. 若结点 z 有左、右两棵子树，则令 z 的直接后继（或直接前驱）代替 z，然后变成 1 或 2

5. **BST 的查找效率**

   二叉排序树的查找效率，主要取决于树的高度

   最好的时间复杂度：O(log2 n)

   最坏的时间复杂度：O(n)

### 7.4.2 平衡二叉树（AVL树）

平衡二叉树：任意结点的左、右子树高度差的绝对值不超过1，即**平衡因子**（左子树高 - 右子树高）的值只可能是-1,0,1

插入、删除和查找在平均和最坏情况下的时间复杂度都为 O(log2 n)

> 1. **AVL树的插入**
>
>    插入和删除会破坏 "平衡" 特性，导致 AVL树 ==失衡==：LL型、LR型、RL型、RR型
>
> 2. **AVL树的删除**
>
> 3. **AVL树的查找**
>
>    深度为 h 的平衡二叉排序树所具有的最少结点数为 Nn，则 N0 = 0，N1 = 1，N2 = 2，...，==Nh = N(h-1) + N(h-2) + 1==
>
>    平衡二叉树的ASL为 O(log2 n)
>

### 7.4.3 红黑树

**1. 红黑树的性质**

红黑树也是一种 **平衡**（特殊的平衡）二叉排序树

一颗红黑树是满足如下红黑性质的 **二叉排序树**：

> 1. 每个结点或是红色，或是黑色的
> 2. **根 **结点是 **黑** 色的
> 3. **叶子** 结点（虚构的外部结点、NULL结点）都是 **黑** 色的
> 4. 不存在两个相邻的红结点（即 ==红== 结点的父结点和孩子结点均是黑色）
> 5. 对每个结点，从该结点出发到任意一个叶子结点的简单了路径上，所含黑结点的数量相同（**黑高相同**）
>
> **左根右，根叶黑；不红红，黑路同**

> 根结点的黑高称为红黑树的树高，从某结点出发（不含该结点）到达任一空叶结点的路径上黑结点的总数
>
> - 结论1：从根结点到叶子结点的最长路径长度不大于最短路径的 **2 倍**
> - 结论2：有 n 个内部结点的红黑树的**高度** h <= **2 * log2 (n+1)**
> - 结论3：新插入红黑树的结点初始都为红色

**2. 红黑树的插入**

> 1. 先查找，确定插入位置（原理同二叉排序树），插入新结点
>
> 2. 新结点是 **根**，则染为 **黑色**
>
> 3. 新结点是 **非根**，则染为 **红色**
>
>    - 若插入新结点后仍然满足红黑树定义，则插入结束
>
>    - 若插入新结点后不满足红黑树定义，则进行 **调整**，使其满足红黑树定义
>
>      调整：看新结点叔叔的 "脸色"
>
>      **叔黑** 则 **旋转**＋**染色**（LL、RR旋转，自己不变，然后父和爷的颜色互换，LR、RL旋转，然后自己和爷的颜色互换）
>
>      **叔红** 则 **染色**＋**变新**（自己不变，叔父爷染色，即黑变红，红变黑，然后爷变新结点，这个新结点需要从头开始判断）

**3. 红黑树的删除**

|                 | 二叉排序树（BST） | 平衡二叉树（AVL）树 | 红黑树    |
| --------------- | ----------------- | ------------------- | --------- |
| 时间复杂度-查找 | O(n)              | O(log2 n)           | O(log2 n) |
| 时间复杂度-插入 | O(n)              | O(log2 n)           | O(log2 n) |
| 时间复杂度-删除 | O(n)              | O(log2 n)           | O(log2 n) |



## 7.5 B 树与 B+ 树

### 7.5.1 B 树（B-树）

二叉排序树是二路查找，B树是**多路平衡查找**，支持**随机查找**

B树的阶：所有结点的孩子的最大值

==一颗 m 阶 B 树== 或是一颗空树：

> - 树中每个结点**至多**有 **m 颗子树**（ **m-1 个关键字**）
> - 若**根结点**不是终端结点，则至少有 2 棵子树（至少 1 个关键字）
> - 除**根结点外**的所有**非叶结点** **至少**有**【m/2】颗子树**（**【m/2】- 1个关键字**，向上取整）
> - 所有的**叶结点**都出现在同一层次上，并且**不携带信息**

B树是所有结点的平衡因子均等于0的多路平衡查找树

### 7.5.2 B+ 树

B+树的所有**非叶子结点**可以看成是**索引**，支持**随机查找**或**顺序查找**

==一颗 m 阶 B+树== 需满足下列条件：

> - 每个分支结点**至多**有 **m 颗子树**（孩子结点）
> - 非叶**根结点**至少有 2 颗子树，其他每个分支结点**至少**有**【m/2】颗子树**（向上取整）
> - 结点的子树个数与关键字个数相等（一个结点有 **m 颗子树**，则必含有 **m 个关键字**）
> - 所有**叶结点**包含全部关键字、信息

B+树的两种查找运算：一种是**从最小关键字开始的顺序查找**，另一种是**从根结点开始的多路查找**

在 B+树的查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径

### 7.5.3 B 树的高度

B树的查找次数等价于B树的高度（==磁盘存取次数==）

含有 **n 个关键字**，m 阶B树的 ==树高 h== 的范围：**logm (n+1)** <= h <= **log【m/2】[(n+1)/2] + 1**（向下取整）

### 7.5.4 B 树的查找

查找：先在 B 树中找结点，然后在结点中找关键字

结点间（随机查找），结点内（顺序或折半查找）

查找到**叶结点**时（对应指针为**空指针**），则说明树中没有对应的关键字，**查找失败**

### 7.5.5 B 树的插入

插入位置一定是最低层中的某个非叶结点

当插入后的结点关键字个数**大于 m-1** 时，必须对结点进行 ==分裂==（裂变），只有根结点发生裂变时，B树的树高才会增高

> 分裂：【m/2】(向上取整)，**左部分**的关键字放在**原结点**，**右部分**的关键字放在**新结点**，**中间**的结点插入原结点的**父结点**

### 7.5.6 B 树的删除

当被删除关键字 k 不在终端结点（最底层非叶子结点）中时

> 用直接前驱或直接后继来代替被删除的关键字

当别删除关键字 k 在终端结点（最底层非叶结点）中时

> 1. **直接删除关键字：**被删除的关键字所在结点的关键字个数 >=【m/2】（向上取整）
>
> 2. **兄弟够借：**被删除的关键字所在结点的关键字个数 = 【m/2】- 1（向上取整）
>
>    父亲下，兄弟上
>
>    右兄弟找最小值
>
>    左兄弟找最大值
>
> 3. **兄弟不够借，向父亲借：**被删除的关键字所在结点的关键字个数 = 【m/2】- 1（向上取整），
>
>    且相邻左右兄弟结点关键字个数均**等于【m/2】- 1**，则将关键字删除后与（或右）兄弟结点及双亲结点中的关键字进行 ==合并==



## 7.6 散列（Hash）表

### 7.6.1 散列函数的构造方法

除留余数法：**H(key) = key % p**

### 7.6.2 处理冲突的方法、

一、开放定址法

> **1.线性探测法**
>
> 冲突发生时，顺序查看表中下一个单元，直到找出一个空闲单元或查遍全表
>
> - 缺点：会造成大量元素在相邻的散列地址上 “聚集” 或 “堆积”，大大降低查找效率
>
> ==“堆积”== 是因为选取的**处理冲突方法**不合适导致的，ASL会因为 “堆积” 而增大

> **2.二次探测法（平方探测法）**
>
> di = 1^2^，-1^2^，2^2^，-2^2^，...，k^2^，-k^2^，其中 k $\leqslant$ m/2，m为散列表长度
>
> 前一步，后一步
>
> - 优点：可以避免出现 “堆积” 问题
> - 缺点：不能探测到散列表上的所有单元，但至少能探测到一半单元

> **3.双散列法**
>

二、链地址法（拉链法）

### 7.6.3 平均查找长度

<strong style="color:#DD5145">散列表查找方法的ASL与元素个数无关</strong>。

> **ASL成功** = 查找次数 / 元素个数
>
> **ASL不成功** = 查找次数 / 散列后的地址个数

散列表的查找效率取决于三个因素：**散列函数**、**处理冲突的方法**、**装填因子**

> ==装填因子==：**&alpha; = 表中记录数n / 散列表长度m**
>
> ASL与装填因子&alpha; 直接相关，不直接依赖 n 或 m
>
> 装填因子&alpha; **越大**，表示装填的记录 **越 “满”**，发生冲突的可能性越大
>
> 但是冲突是不可避免的，与装填因子&alpha; 无关

