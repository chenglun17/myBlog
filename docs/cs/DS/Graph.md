# 第六章--图

## 6.1 图的基本概念

### 1.图的定义

图G由顶点集V (Vertex) 和边集E (Edge) 组成，记为G=(V, E)

- V：顶点的有穷非空集合
- E：边的有穷集合

1. **有向图**

> <v,w>称为从v到w的弧，v 称为弧尾，w 称为弧头

2. **无向图**

> 边是顶点的无序对，记为（v,w）或（w,v）

3. **完全图（简单完全图）**

> - <strong style="color:#DD5145">有 $C_n^2$ = n(n-1)/2 条边</strong> 的无向图称为**(无向)完全图**，即**任意两点**之间都有一条边**直接相连**
> - <strong style="color:#DD5145">有 $2C_n^2$ = n(n-1) 条弧</strong> 的有向图称为**有向完全图**，即**任意两点**之间都存在**方向相反**的**两条弧**

4. **子图和生成子图**

> - V' 是 V 的子集，且 E' 是 E 的子集，则称 G' 是 G 的子图
> - **生成子图**必须包含**全部顶点**，但只包含一部分边（也可以是全部）

5. **连通、连通图、连通分量**

> - 在 **无向图** 中，若从顶点 v 到顶点 w 有路径存在，则称 v 和 w 是**连通**的
>
> - 若图G中任意两个顶点都是连通（不需要直接相连）的，则称图G为**连通图**
>
> - 无向图中的**极大连通子图**称为无向图的**连通分量**
>
>   **极大连通子图**：该子图是G的连通子图，将G的任何不在该子图上的顶点加入，子图不在连通
>
>   **极小连通子图**：该子图是G的连通子图，在该子图中删除任何一条边，子图不在连通
>   
> - 若有 n 个顶点的图G是**连通图**，则**最少**有 n-1 条边
>
> - 若有 n 个顶点的图G是**非联通图**，则**最多**有 C2(n-1) 条边

6. **强连通图、强连通分量**

> - 在 **有向图** 中，若有一对顶点 v 和 w，从 v 到 w 和从 w 到 v 之间都有路径，则称这两个顶点是**强连通**的
>- 若图G中任意一对顶点都是强连通的，则此图G为**强连通图**
> - 有向图中的**极大强连通子图**称为有向图的**强连通分量**
>- 若有 n 个顶点的图G是**强连通图**，则最少有 n 条边（形成环路）

7. **生成树、生成森林**

> - **生成树**：是包含无向图的全部顶点的**极小连通子图**，且**不存在回路**的图，但加一条边必然形成回路
>
>   生成树中任意两个顶点之间的路径是唯一的
>   
>   一个有 n 个顶点的 **连通无向图** 的生成树含有 n-1 条边，但是 n 个顶点 n - 1 条边的图不一定是生成树
>   
> - **生成森林**：在非连通图中，连通分量的生成树构成了非连通图的生成森林

8. **有向树**

> 一个顶点的入度为 0、其余顶点的入度为 1 的有向图，称为有向树

### 2.其他概念

1. **顶点的度**

> - 无向图中，顶点 v 的度是指依附于顶点 v 的边的条数，记为 TD(v)
>
>   <strong style="color:#DD5145">无向图</strong> 的 **全部顶点的度之和 = 边数的2倍**
>
> - 有向图中，入度是以顶点 v 为终点的有向边的数目，记为 ID(v)；出度是以顶点 v 为起点的有向边的数目，记为 OD(v)
>
>   顶点 v 的度 = 其入度与出度之和，即 TD(v) = ID(v) + OD(v)
>
>   <strong style="color:#DD5145">有向图</strong> 的 **全部顶点的入度之和 = 出度之和 = 边的数目**

2. **边的权和网**

> 带权值的图称为带权图，也称网

3. **路径、路径长度和回路**

> - 路径：连续的边构成的顶点序列
>
> - 路径长度：路径上边或弧的数目/权值之和
>
> - 回路(环)：第一个顶点和最后一个顶点相同的顶点
>
>   <strong style="color:#DD5145">若一个图有 n 个顶点，并且有大于 n-1 条边</strong>，则此图一定**有环路**



## 6.2 图的存储

### 1.邻接矩阵法(顺序存储结构)

适用于稠密图

> - 顶点表：用一个一维数组存储图中顶点的信息
>
> - 邻接矩阵：用一个二维数组存储图中边的信息
>
>   在定义邻接矩阵时，顶点在邻接矩阵中的顺序必须按照顶点数组的顺序
>
> - 邻接矩阵表示法的空间复杂度为 O(|v|^2)
>
>   <strong style="color:#DD5145">只与顶点数目有关</strong>，与边数无关

> - **无向图** 的邻接矩阵是一个对称矩阵且 **唯一**
>
>   对于特定顶点每行或每列的非零元素的个数 = 该顶点的度
>   
>   无向图的邻接矩阵是 **对称矩阵**，可以采用 **压缩存储** 来减少规模

> - **有向图** 的邻接矩阵可能是一个对称矩阵
>
>   **行 **为 **出度** 边
>
>   **列** 为 **入度 **边
>
>   邻接矩阵中非∞元素（或非零元素）的个数 = 图的弧的数目

### 2.邻接表法（链式存储结构）

适用于稀疏图

> 图的邻接表 **不唯一**，取决于建立邻接表的算法及边的 **输入顺序**

> - **无向图** 的空间复杂度为 O(n+2e)，每条边存储两次
>
> - **有向图** 的空间复杂度为 O(n+e)
>
>   **正向**邻接表：**边结点**表示**出度**信息
>
>   逆向邻接表：边结点表示入度信息

邻接表中存在两种结点：**顶点表结点**和**边表结点**。

顶点表结点：**| data | firstarc |**

- data：顶点域
- fristarc：边表头指针

边表结点： **| adjvex | nextarc | info |**

- adjvex：邻接点域
- nextarc：指针域
- info：权值

### 3.十字链表（存储有向图）



### 4.邻接多重表（存储无向图）



 ## 6.3 图的遍历

图的遍历是指从图中的某一点出发，按照某种搜索算法沿着图中的边对图中的所有顶点访问一次且仅访问一次

### 1.深度优先搜索(DFS)

> 类似于树的**先序遍历**
>
> <strong style="color:#DD5145">可以回退（回溯）</strong> 到最近被访问的顶点
>
> 对**连通图**调用 DFS 才能产生**深度优先生成树**，否则产生的是**深度优先生成森林**

> DFS算法是一种**递归算法**，需要借助**栈**，空间复杂度为 O(|V|)
>
> 时间复杂度只与存储结构有关
>
> - 以邻接矩阵表示时，时间复杂度为 O(|V|^2)
> - 以(正)邻接表表示时，时间复杂度为 O(|V| + |E|)

<strong style="color:#DD5145">深度优先搜索（DFS）可以判断 有向图 是否有环</strong>。

### 2.广度优先搜索(BFS)

> 类似于二叉树的**层序遍历**
>
> 不会出现往回退的情况
>
> 在广度遍历的过程中，可以得到一颗广度优先生成树

> BFS算法是一种**非递归**算法，需要借助**队列**，空间复杂度为 O(|V|)
>
> - 以邻接矩阵表示时，时间复杂度为 O(|V|^2)
> - 以邻接表表示时，时间复杂度为 O(|V| + |E|)

<strong style="color:#DD5145">广度优先搜索（BFS）可以用来求解 非带权图 的单源最短路径问题</strong>。

### 3.图的遍历与图的连通性

1. **无向图**

> - 连通图：仅需要一次遍历
> - 非连通图：DFS/BFS 函数调用的次数 = 连通分量个数

2. **有向图**

> - 强连通图：从任一顶点出发都只需要调用一次 DFS/BFS

## 6.4 图的应用

### 1.最小生成树 MST

> 最小生成(代价)树**不是唯一**的，但边的权值之和（代价）是**唯一**的
>
> 最小生成树的边数 = 顶点数 - 1，即 E=V-1
>
> **最小权值**一定会出现在所有的 MST 中
>
> **最小权值的边**不一定出现在所有的 MST 中，但一定会出现在某颗 MST 中

- **Prim（普里姆）算法**

  选择顶点，适用于**稠密图**，时间复杂度为 O(|V|^2)

> - 步骤：1.初始时从图中**任取一顶点**加入顶点集合 T
>
>   ​		   2.每次从图中选择一个与当前 T 中**距离最近**的顶点，并将该顶点加入 T 中
>
> 类似贪吃蛇

- **Kruskal（克鲁斯卡尔）算法**

  选择边，适用于**稀疏图**，时间复杂度为 O(|E| log |E|)

> - 步骤：1.先对**边的权值**进行按依次**递增排序**
>
>   ​		   2.每次都**选取**权值**最小边**，且 ==不能形成环路==

> - 当图的**权值都不相等**时：
>
>   不同算法（Prim或Kruskal）构造的最小生成树是唯一的，但不同算法的构造过程可能是不唯一的
>
>   **同一个算法**的构造过程是**唯一**的，并且构成的最小生成树也是**唯一**的
>
> - 当图的**权值相等**时：
>
>   同一个算法的最小生成树的构造过程可能不唯一
>
>   不同算法的最小生成树的构造过程可能不唯一
>
>   不同算法构造的最小生成树可能不唯一

### 2.最短路径

- **Dijkstra（迪杰斯特拉）算法**，求**单源最短路径**

> - 适用于带权图
> - 无论是采用 邻接矩阵 还是 邻接表 表示时，时间复杂度都为 O(|V|^2)
> - Dijkstra 算法不适用于边上带有负权值情况，也**不适用于负回路**（带负权值的边组成的回路）

> - Prim 解决的问题是找到 n-1 条边，使这 n-1 条边的权值之和最小
>
> - Dijkstra 是找到顶点（源点）到其他所有点的最短距离，始终要保持其他点到顶点（源点）的距离最短

- **Floyd（弗洛伊德）算法**，求**各顶点之间最短路径**

  适用于带权图

  Floyd 算法允许图中有带有负权值的边，但**不允许负回路**

  时间复杂度为 O(|V|^3)

  也可以用 单源最短路径算法 来解决 各顶点之间的最短路径 问题，时间复杂度为 O(|V|^2) * |V| = O(|V|^3)

### 3.拓扑排序（AOV）

> **有向 无环图**，DAG，Directed Acycline Graph

- **AOV网**，Activity On Vertex network，顶点表示活动的网络

> - 在 AOV网中不能有环，即 **有环一定没有拓扑序列，有拓扑序列一定没有环**
>
> - 采用邻接矩阵表示时，时间复杂度为 O(|V|^2)
> - 采用邻接表表示时，时间复杂度为 O(|V| + |E|)
>
> - 一个 AOV 网的拓扑排序**不唯一**

- 拓扑排序步骤：

> 1. 从AOV网中选择一个**没有前驱**（入度为0）的顶点并**输出顶点**
> 2. 从网中**删除**该**顶点**和所有以它为起点的**有向边**
> 3. 重复1. 2.，直到当前的AOV网为空 或者 当前网中不存在无前驱的顶点（存在环路）为止

> - 有向无环图的拓扑序列唯一，图也不一定唯一
> - ==拓扑排序可以判断有向图是否存在回路==
>

### 4.关键路径（AOE）

- **AOE网**，Activity On Edge network，**边**表示**活动**，**顶点**表示**事件**的网络，是**带权 有向 无环图**

> - 路径长度：路径上各个活动所持续的时间之和
> - **关键路径**：从源点到汇点的所有路径中，具有**最大的路径长度**的路径
> - 关键路径的长度：完成整个工程的最短时间
> - 关键活动：关键路径上的活动
>
> - 网中的关键路径是**不唯一**的

- 求关键路径是以**拓扑排序**为基础的

> - **事件 vk** 的最早发生时间 **ve(k)**，最迟发生时间 **vl(k)**
>
> - **活动 ai** 的最早开始时间 **e(i)**，最晚开始时间 **l(i)**
>
> - 时间余量（松弛量）：**d(i) = l(i) - e(i)**
> - l(i) - e(i) = 0 ，即 **l(i) = e(i)** 是活动 ai 是 **关键活动**

> - 活动的最早开始时间：采用正推法，从源点开始，取最大的路径
>- 活动的最晚开始时间：采用反推法，从终点（汇点）开始，取最小的路径

- 求关键路径的步骤

> 1. 从**源点**出发，令ve(源点) = 0，按拓扑有序求其余顶点的**最早**发生时间 ve(k) = **Max**{ ve(j) + Weight(vj,vk) }，可求出==关键路径==
> 2. 从**汇点**出发，令vl(汇点) = ve(汇点)，按逆拓扑有序求其余顶点的**最迟**发生时间 vl(k) = **Min**{ ve(j) - Weight(vj,vk) }
> 3. 弧的最早开始时间 e(i) = 该弧的**起点**的顶点的 ve(k)
> 4. 弧的最晚开始时间 l(i) = 该弧的**终点**的顶点的 vl(k) - 该弧持续时间 ai
> 5. 求 AOE 网中的所有活动的差额 d(i) = l(i) - e(i) ，找出所有 d(i) = 0 的活动构成关键路径