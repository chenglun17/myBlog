# 第五章--树

## 5.1 树

### 5.1.1 树的存储结构

1. **双亲表示法**

> 找双亲容易，找孩子难
>
> 双亲结点结构：| data | parent |

1. **孩子链表表示法**

> 找孩子容易，找双亲难
>
> 孩子结点结构：| child | next |
>
> 双亲结点结构：| data | firstchild |

1. **孩子兄弟表示法（二叉树表示法）**

> 方便实现树转换为二叉树，找孩子容易，找双亲难，左孩有兄
>
> 结点结构：| firstchild | data | nextsibling |

### 5.1.2 树的性质

> 1. 树的结点个数 = 所有结点的度数之和 + 1
>
> 2. 对于 m度树，定义叶子结点个数为 n0，度为1的结点个数为 n1，...，度为m的结点个数为 nm，
>
>    则有 n0= n2 + 2 n3 + 3 n4 + ... + (n-1) nm + 1
>
> 3. 度为 m 的树中 ==第 i 层== 上**至多**有 m ^(i-1) 个结点（ i >1)
>
> 4. 高度(深度)为 h 的 m叉树**至多**有 (m^h - 1) / (m-1) 个结点，**至少**有 h 个结点
>
> 5. 具有 n个结点的 m叉树 的 ==最小高度== 为 【log m [n(m-1) +1]】(向上取整)，==最大高度== 为 n（每层结点最少）
>
> 6. n 个结点的树中有 n-1 条边

## 5.3 二叉树

二叉树是有序树，但度为2的树可能是无序树，二叉树的每个结点至多只有两棵子树，且子树有左右之分，次序不能颠倒

### 5.2.1 二叉树的性质

> 1. 非空二叉树上的 叶子结点数 = 度为2 的结点数 + 1，即 n0 = n2 + 1
> 2. 非空二叉树上 ==第 k 层== 上**至多**有 **2 ^(k-1)** 个结点（k >=1）
> 3. 高度为 h 的二叉树**至多**有 **2^h - 1** 个结点（h >=1）
> 4. 具有 n 个 (n >0) 结点的 **完全二叉树** 的 ==高度==为 **【log 2 (n+1)】 (向上取整)** 或 【log 2 n】+ 1 (向下取整) 
> 5. 对 **完全二叉树** 按从上到下、从左到右的顺序依次执行编号1，2，...，n，则有以下关系：
>    - 当 i > 1 时，结点 i 的双亲的编号为【2 / i】(向下取整)
>    - 当 2i <= n 时，结点 i 的左孩子编号为 2i，否则无左孩子
>    - 当 2i +1 <= n 时，结点 i 的右孩子编号为 2i + 1，否则无右孩子
>    - 结点 i 所在 ==层次（深度）== 为【log 2 i】+1 (向下取整)

### 5.2.2 二叉树的存储结构

> 1. **顺序存储结构**
>
>    适用于 满二叉树和完全二叉树
>
>    对于一般的二叉树，比较浪费存储空间，最坏的情况，高度为 h 且只有 h 个结点的单支树需要占近 2^h - 1 个存储单元
>
> 2. **链式存储结构**
>
>    二叉树链式存储的结点结构： | lchild | data | rchild |
>
>    含有 n 个结点的二叉链表中，含有 n+1 个空链域
>
>    三叉链表的存储结构： | lchild | data | parent | rchild |

### 5.2.3 二叉树的遍历

> 先序（NLR），中序（LNR），后序（LRN）
>
> 遍历是指按照某条路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次
>
> 时间复杂度均为 O(n)
>
> 最坏情况下，二叉树是有 n个结点且深度为 n 的单枝树，空间复杂度为 O(n)

### 5.2.4 特殊二叉树

**1. 满二叉树**

**2. 完全二叉树**

> 若 **i <= 【n/2】(向下取整)**，则结点 i 为**非终端结点**，否则为叶子结点
>
> 叶子结点只可能在最底下两层出现，且**叶子结点**的范围为 **[n/2 + 1，n]**
>
> 度为1 的结点个数最多只有一个（即度为1的个数只能有1个或0个），且该结点只有左孩子没有右孩子
>
> n 个结点的完全二叉树的**树高** $log_2{(n+1)}$ (**向上取整**) 或 $log_2{n} +1$ (**向下取整**) 

**3. 二叉排序树（BST）**

> 结点的关键字：左子树 < 根结点 < 右子树

**4. 平衡二叉树（AVL树）**

> 树上任一结点的左子树和右子树的深度之差不超过 1

## 5.4 线索二叉树

二叉树是一种逻辑结构，而线索二叉树是加上了**线索**后的链表结构，即是一种物理结构（存储结构）

线索：是指向结点前驱和后继的指针

线索化的实质：遍历一次二叉树

> 引入线索二叉树的目的：为了加快查找结点前驱和后继的速度
>
> 一颗任意的二叉树，也任意使用 先序/中序/后序 线索化，则线索化后其空链域最多有 2 个
>
> 使用了线索二叉树后，前序和中序遍历将不需要栈的支持，但后序遍历仍需要栈的支持
>
> 对于后序遍历的线索二叉树，找结点的直接后继依然困难

## 5.5 树和森林

### 5.5.1 树的存储结构

1. **双亲表示法**

> 结点结构：| data | parent |
>
> 找双亲容易，找孩子难

2. **孩子表示法**（孩子链表表示法）

> 双亲结点结构：| data | firstchild |
>
> 孩子结点结构：| child | next |
>
> 找孩子容易，找双亲难

2. **孩子兄弟表示法**（二叉树表示法）

> 二叉链表结点：| firschild | data | nextsibling |
>
> 左孩右兄，找孩子容易，找双亲难

### 5.5.2 树、森林与二叉树的转换

任何一颗和树对应的二叉树，其结点的右子树一定为空

### 5.5.3 树和森林的遍历

> 1. **树的遍历**
>
>    先根遍历
>
>    后根遍历
>
>    树没有中序遍历
>
> 2. **森林的遍历**
>
>    先序遍历森林
>
>    中序遍历森林
>
> 树的**先根**遍历 = 对应二叉树的**先序**遍历 = 森林的先序遍历
>
> 树的**后根**遍历 = 对应二叉树的**中序**遍历 = 森林的中序遍历

## 5.6 树与二叉树的应用

### 5.6.1 哈夫曼树

在含有 n 个**带权叶结点**的二叉树中，其中**带权路径长度（WPL，Weighted Path Length）**最小的二叉树称为**哈夫曼树**（最优二叉树）

> WPL的定义：WPL = 所有（叶结点的权值Wi * 该结点的深度Li）
>
> 在哈夫曼树中，WPL = 所有非叶结点的权值和

> 满二叉树不一定是哈夫曼树（哈夫曼树本质不是二叉树）
>
> 哈夫曼树不一定是完全二叉树
>
> 哈夫曼树只有 0 度结点和 2 度结点
>
> 哈夫曼树不唯一，因为左、右子树可以交换，但WPL值唯一
>
> ==n 个叶子结点构造哈夫曼树，则总结点数为 2n - 1==

### 5.6.2哈夫曼编码

> 前缀编码：没有一个编码是另一个编码的前缀
>
> 左0右1

### 5.6.3 并查集

 并查集的原理

> 用集合中的一个元素代表集合

并查集的应用

> 判断连通性、判断环
>
> Kruskal算法 = 排序 + 并查集

并查集的操作

> 查询 find：判断两个点是否属于同一集合
>
> 合并 union：将两个点所在集合合并

并查集的存储方式

> 逻辑：通常用 树（森林）的 ==双亲表示== 作为并查集的存储结构
>
> 找双亲容易，找孩子难，双亲结点结构：| data | parent |

> 存储：数组
>
> 数组元素的下标代表元素名，根结点的下标代表集合名，根结点的双亲结点为负数